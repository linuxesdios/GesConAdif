#!/usr/bin/env python3
"""
Script para compilar Generador de Actas ADIF con estructura SIMPLIFICADA
ESTRUCTURA FINAL:
- generador_actas.exe (ejecutable principal SIN consola)
- generador_actas_console.exe (ejecutable CON consola)
- _internal/ (archivos internos del programa)
  - BaseDeDatos/ (movido DENTRO de _internal)
- obras/ (PRESERVADO - carpeta de trabajos)

ARCHIVOS ELIMINADOS AUTOM√ÅTICAMENTE:
- ejecutar.bat
- README.txt
- historial_documentos.json
- generador_actas.exe.old
- obras_backup_compilacion/
- reportes/
"""
import os
import sys
import subprocess
import shutil
from pathlib import Path
import time

def activar_entorno_virtual():
    """Detecta y activa entorno virtual autom√°ticamente"""
    posibles_entornos = [
        "venv/Scripts/python.exe",
        "env/Scripts/python.exe",
        "adif_env/Scripts/python.exe",
        "entorno_adif/Scripts/python.exe"
    ]
    
    for entorno in posibles_entornos:
        if os.path.exists(entorno):
            print(f"‚úÖ Entorno virtual detectado: {entorno}")
            return entorno
    
    print("‚ö†Ô∏è No se detect√≥ entorno virtual, usando Python global")
    return sys.executable

def preservar_archivos_criticos():
    """Respalda SOLO archivos cr√≠ticos esenciales"""
    print("\nüõ°Ô∏è Preservando archivos cr√≠ticos...")
    
    # Solo preservar BaseDatos.json y carpeta obras
    archivos_preservar = {
        "BaseDatos.json": None,
        "_internal/BaseDatos.json": None,
        "dist/generador_actas/_internal/BaseDatos.json": None,
        "_internal/BaseDatos/BaseDatos.json": None,
        "dist/generador_actas/_internal/BaseDatos/BaseDatos.json": None,
    }
    
    carpetas_preservar = {
        "obras": None,
        "dist/generador_actas/obras": None,
        "BaseDatos": None,
        "_internal/BaseDatos": None,
        "dist/generador_actas/_internal/BaseDatos": None,
    }
    
    backups = {
        "archivos": {},
        "carpetas": {}
    }
    
    # Respaldar archivos
    for archivo in archivos_preservar.keys():
        if os.path.exists(archivo):
            backup_path = f"{archivo}.backup_compilacion"
            try:
                shutil.copy2(archivo, backup_path)
                backups["archivos"][archivo] = backup_path
                print(f"‚úÖ Respaldado: {archivo} ‚Üí {backup_path}")
            except Exception as e:
                print(f"‚ö†Ô∏è Error respaldando {archivo}: {e}")
    
    # Respaldar carpetas
    for carpeta in carpetas_preservar.keys():
        if os.path.exists(carpeta) and os.path.isdir(carpeta):
            backup_path = f"{carpeta.replace('/', '_').replace('\\', '_')}_backup_temp"
            try:
                if os.path.exists(backup_path):
                    shutil.rmtree(backup_path)
                shutil.copytree(carpeta, backup_path)
                backups["carpetas"][carpeta] = backup_path
                print(f"‚úÖ Respaldado: {carpeta}/ ‚Üí {backup_path}/")
            except Exception as e:
                print(f"‚ö†Ô∏è Error respaldando {carpeta}: {e}")
    
    return backups

def limpiar_archivos_no_deseados():
    """Elimina archivos espec√≠ficos que NO queremos en la estructura final"""
    print("\nüßπ Eliminando archivos no deseados...")
    
    archivos_eliminar = [
        "dist/generador_actas/ejecutar.bat",
        "dist/generador_actas/README.txt", 
        "dist/generador_actas/historial_documentos.json",
        "dist/generador_actas/generador_actas.exe.old",
        "dist/generador_actas/validar_entorno.py",    # Eliminar validar_entorno si existe
        "ejecutar.bat",
        "README.txt",
        "historial_documentos.json",
        "validar_entorno.py"                          # Tambi√©n en ra√≠z
    ]
    
    carpetas_eliminar = [
        "dist/generador_actas/obras_backup_compilacion",
        "dist/generador_actas/reportes",
        "obras_backup_compilacion",
        "reportes"
    ]
    
    # Eliminar archivos
    for archivo in archivos_eliminar:
        if os.path.exists(archivo):
            try:
                os.remove(archivo)
                print(f"üóëÔ∏è Eliminado: {os.path.basename(archivo)}")
            except Exception as e:
                print(f"‚ö†Ô∏è Error eliminando {archivo}: {e}")
    
    # Eliminar carpetas
    for carpeta in carpetas_eliminar:
        if os.path.exists(carpeta):
            try:
                shutil.rmtree(carpeta)
                print(f"üóëÔ∏è Carpeta eliminada: {os.path.basename(carpeta)}/")
            except Exception as e:
                print(f"‚ö†Ô∏è Error eliminando {carpeta}: {e}")

def verificar_dependencias(python_exe):
    """Verifica que las dependencias est√©n disponibles"""
    dependencias = ['PyQt5', 'openpyxl', 'lxml', 'docx2pdf', 'PyInstaller']
    
    print("\nüîç Verificando dependencias...")
    for dep in dependencias:
        try:
            resultado = subprocess.run([
                python_exe, "-c", f"import {dep.replace('-', '_').replace('python_', '')}"
            ], capture_output=True, check=True)
            print(f"‚úÖ {dep}")
        except subprocess.CalledProcessError:
            print(f"‚ùå {dep} - NO ENCONTRADO")
            return False
    
    return True

def verificar_archivos_necesarios():
    """Verifica que todos los archivos necesarios existan"""
    print("\nüîç Verificando archivos necesarios...")
    
    # Preferir archivos optimizados si existen
    main_file = "main_py_optimized.py" if os.path.exists("main_py_optimized.py") else "main_py.py"
    controlador_file = "controladores/controlador_grafica.py"
    
    archivos_criticos = [
        main_file,
        "modelos_py.py", 
        "helpers_py.py",
        controlador_file
    ]
    
    for archivo in archivos_criticos:
        if os.path.exists(archivo):
            print(f"‚úÖ {archivo}")
        else:
            print(f"‚ùå {archivo} - NO ENCONTRADO")
            return False
    
    return True

def compilar_aplicacion_doble(python_exe):
    """Compila AMBOS ejecutables: normal y con consola"""
    print(f"\nüöÄ Compilando AMBOS ejecutables con: {python_exe}")
    
    # Preferir archivo optimizado si existe
    main_file = "main_py_optimized.py" if os.path.exists("main_py_optimized.py") else "main_py.py"
    
    # Buscar icono
    posibles_iconos = ["images/icono.ico", "icono.ico", "resources/icono.ico", "ui/icono.ico"]
    icono_encontrado = None
    for icono in posibles_iconos:
        if os.path.exists(icono):
            icono_encontrado = icono
            break
    
    # CONFIGURACI√ìN BASE COM√öN
    comando_base = [
        python_exe, "-m", "PyInstaller",
        "--onedir",
        "--optimize=2",
        "--noupx", 
        "--noconfirm",
        "--distpath=dist_temp",
        "--workpath=build",
        
        # ARCHIVOS DE DATOS
        "--add-data=controladores;controladores",
        "--add-data=ui;ui",
        "--add-data=plantillas;plantillas",
        "--add-data=images;images",
        "--add-data=BaseDatos.json;.",
        "--add-data=obras;obras",  # Incluir carpeta obras en compilaci√≥n
        
        # LIBRER√çAS ESENCIALES
        "--hidden-import=PyQt5.QtCore",
        "--hidden-import=PyQt5.QtWidgets", 
        "--hidden-import=PyQt5.QtGui",
        "--hidden-import=PyQt5.uic",
        "--hidden-import=openpyxl",
        "--hidden-import=lxml",
        "--hidden-import=docx2pdf",
        "--hidden-import=controladores.controlador_grafica",
        "--hidden-import=controladores.controlador_json",
        "--hidden-import=controladores.controlador_documentos",
        "--hidden-import=controladores.controlador_pdf",
        "--hidden-import=controladores.controlador_backup",
        "--hidden-import=controladores.controlador_routes",
        "--hidden-import=controladores.Controlador_selector",
        "--hidden-import=modelos_py",
        "--hidden-import=helpers_py",
        
        # EXCLUIR INNECESARIOS
        "--exclude-module=tkinter",
        "--exclude-module=matplotlib",
        "--exclude-module=scipy",
        "--exclude-module=jupyter",
        "--exclude-module=IPython",
        "--exclude-module=notebook",
        "--exclude-module=PySide6",
        "--exclude-module=PySide2", 
        "--exclude-module=PyQt6"
    ]
    
    # A√±adir icono si se encontr√≥
    if icono_encontrado:
        comando_base.extend([f"--icon={icono_encontrado}"])
        print(f"‚úÖ Icono incluido: {icono_encontrado}")
    
    # 1. COMPILAR EJECUTABLE SIN CONSOLA (normal)
    print("\n‚öôÔ∏è Compilando generador_actas.exe (SIN consola)...")
    comando_sin_consola = comando_base.copy()
    comando_sin_consola.extend([
        "--windowed",  # SIN consola
        "--name=generador_actas",
        main_file
    ])
    
    try:
        resultado = subprocess.run(comando_sin_consola, check=True, cwd=os.getcwd())
        print("‚úÖ Compilaci√≥n SIN consola exitosa")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå ERROR compilando SIN consola: {e}")
        return False
    
    # Renombrar el resultado para evitar conflictos
    dist_sin_consola = "dist_temp/generador_actas"
    dist_backup = "dist_temp/generador_actas_windowed"
    if os.path.exists(dist_sin_consola):
        if os.path.exists(dist_backup):
            shutil.rmtree(dist_backup)
        shutil.move(dist_sin_consola, dist_backup)
        print("üì¶ Ejecutable SIN consola guardado temporalmente")
    
    # 2. COMPILAR EJECUTABLE CON CONSOLA
    print("\n‚öôÔ∏è Compilando generador_actas_console.exe (CON consola)...")
    comando_con_consola = comando_base.copy()
    comando_con_consola.extend([
        "--console",  # CON consola
        "--name=generador_actas_console", 
        main_file
    ])
    
    try:
        resultado = subprocess.run(comando_con_consola, check=True, cwd=os.getcwd())
        print("‚úÖ Compilaci√≥n CON consola exitosa")
    except subprocess.CalledProcessError as e:
        print(f"‚ùå ERROR compilando CON consola: {e}")
        return False
    
    # Renombrar el resultado
    dist_con_consola = "dist_temp/generador_actas_console"
    dist_console_backup = "dist_temp/generador_actas_console_final"
    if os.path.exists(dist_con_consola):
        if os.path.exists(dist_console_backup):
            shutil.rmtree(dist_console_backup)
        shutil.move(dist_con_consola, dist_console_backup)
        print("üì¶ Ejecutable CON consola guardado temporalmente")
    
    return True

def crear_estructura_simplificada(backups):
    """Crea la estructura SIMPLIFICADA requerida"""
    print("\nüèóÔ∏è Creando estructura SIMPLIFICADA...")
    
    # Definir rutas
    dist_backup_windowed = "dist_temp/generador_actas_windowed"
    dist_backup_console = "dist_temp/generador_actas_console_final"
    dist_final = "dist/generador_actas"
    
    # Limpiar destino si no hay archivos cr√≠ticos
    if os.path.exists("dist"):
        critical_files = [
            f"{dist_final}/_internal/BaseDatos/BaseDatos.json",
            f"{dist_final}/obras"
        ]
        has_critical = any(os.path.exists(f) for f in critical_files)
        
        if not has_critical:
            print("üßπ Limpiando destino (no hay archivos cr√≠ticos)...")
            shutil.rmtree("dist")
        else:
            print("üõ°Ô∏è Preservando archivos cr√≠ticos en destino...")
    
    # Crear estructura base
    try:
        Path(dist_final).mkdir(parents=True, exist_ok=True)
        Path(f"{dist_final}/_internal").mkdir(exist_ok=True)
        print("‚úÖ Estructura base creada")
    except Exception as e:
        print(f"‚ùå Error creando estructura: {e}")
        return False
    
    # 1. COPIAR EJECUTABLE SIN CONSOLA
    print("\nüöÄ Copiando generador_actas.exe (SIN consola)...")
    exe_windowed_origen = f"{dist_backup_windowed}/generador_actas.exe"
    exe_windowed_destino = f"{dist_final}/generador_actas.exe"
    
    if os.path.exists(exe_windowed_origen):
        try:
            if os.path.exists(exe_windowed_destino):
                os.remove(exe_windowed_destino)
            shutil.copy2(exe_windowed_origen, exe_windowed_destino)
            size_mb = os.path.getsize(exe_windowed_destino) / (1024 * 1024)
            print(f"‚úÖ generador_actas.exe copiado ({size_mb:.1f} MB)")
        except Exception as e:
            print(f"‚ùå Error copiando ejecutable sin consola: {e}")
            return False
    else:
        print(f"‚ùå No se encontr√≥: {exe_windowed_origen}")
        return False
    
    # 2. COPIAR EJECUTABLE CON CONSOLA
    print("\nüñ•Ô∏è Copiando generador_actas_console.exe (CON consola)...")
    exe_console_origen = f"{dist_backup_console}/generador_actas_console.exe"
    exe_console_destino = f"{dist_final}/generador_actas_console.exe"
    
    if os.path.exists(exe_console_origen):
        try:
            if os.path.exists(exe_console_destino):
                os.remove(exe_console_destino)
            shutil.copy2(exe_console_origen, exe_console_destino)
            size_mb = os.path.getsize(exe_console_destino) / (1024 * 1024)
            print(f"‚úÖ generador_actas_console.exe copiado ({size_mb:.1f} MB)")
        except Exception as e:
            print(f"‚ùå Error copiando ejecutable con consola: {e}")
            return False
    else:
        print(f"‚ùå No se encontr√≥: {exe_console_origen}")
        return False
    
    # 3. COPIAR ARCHIVOS _INTERNAL
    print("\nüì¶ Copiando archivos _internal...")
    
    # Usar el _internal de cualquiera de los dos (son iguales)
    internal_origen = f"{dist_backup_windowed}/_internal"
    internal_destino = f"{dist_final}/_internal"
    
    if os.path.exists(internal_origen):
        try:
            # Copiar todos los archivos de _internal
            for item in os.listdir(internal_origen):
                item_origen = os.path.join(internal_origen, item)
                item_destino = os.path.join(internal_destino, item)
                
                if os.path.isdir(item_origen):
                    if os.path.exists(item_destino):
                        shutil.rmtree(item_destino)
                    shutil.copytree(item_origen, item_destino)
                    print(f"   üìÅ {item}/")
                else:
                    if os.path.exists(item_destino):
                        os.remove(item_destino)
                    shutil.copy2(item_origen, item_destino)
                    print(f"   üìÑ {item}")
            
            print("‚úÖ Archivos _internal copiados")
        except Exception as e:
            print(f"‚ùå Error copiando _internal: {e}")
            return False
    else:
        print(f"‚ùå No se encontr√≥ _internal en: {internal_origen}")
        return False
    
    # 4. MOVER BaseDatos DENTRO DE _internal
    print("\nüóÑÔ∏è Configurando BaseDatos dentro de _internal...")
    
    # Crear carpeta BaseDatos dentro de _internal
    basedatos_destino = f"{dist_final}/_internal/BaseDatos"
    try:
        Path(basedatos_destino).mkdir(exist_ok=True)
        print(f"‚úÖ Carpeta {basedatos_destino}/ creada")
    except Exception as e:
        print(f"‚ùå Error creando carpeta BaseDatos: {e}")
    
    # 5. RESTAURAR CARPETA OBRAS Y BaseDatos desde backups
    print("\nüõ°Ô∏è Restaurando archivos cr√≠ticos...")
    print(f"üìã Backups disponibles: {list(backups['carpetas'].keys())}")
    
    # Restaurar BaseDatos
    for carpeta_original, backup_path in backups["carpetas"].items():
        if backup_path and os.path.exists(backup_path):
            carpeta_nombre = os.path.basename(carpeta_original)
            
            if carpeta_nombre == "BaseDatos" or "BaseDatos" in carpeta_original:
                # BaseDatos va DENTRO de _internal
                destino = f"{dist_final}/_internal/BaseDatos"
                print(f"   üìÇ Restaurando BaseDatos ‚Üí _internal/BaseDatos/")
            elif carpeta_nombre == "obras":
                # obras va en la ra√≠z
                destino = f"{dist_final}/obras"
                print(f"   üìÇ Restaurando obras ‚Üí obras/")
            else:
                continue
            
            try:
                if os.path.exists(destino):
                    shutil.rmtree(destino)
                
                shutil.move(backup_path, destino)
                print(f"‚úÖ Restaurado: {carpeta_nombre}/ ‚Üí {os.path.relpath(destino, dist_final)}/")
            except Exception as e:
                print(f"‚ö†Ô∏è Error restaurando {carpeta_nombre}: {e}")
                try:
                    shutil.copytree(backup_path, destino)
                    shutil.rmtree(backup_path)
                    print(f"‚úÖ Copiado (alternativo): {carpeta_nombre}/")
                except:
                    print(f"‚ùå No se pudo restaurar {carpeta_nombre}")
    
    # Restaurar archivos BaseDatos.json
    print(f"üìã Archivos de backup: {list(backups['archivos'].keys())}")
    for archivo_original, backup_path in backups["archivos"].items():
        if backup_path and os.path.exists(backup_path) and "BaseDatos.json" in archivo_original:
            # Copiar a _internal/BaseDatos/ (para funcionamiento interno)
            destino_internal = f"{dist_final}/_internal/BaseDatos/BaseDatos.json"
            # Tambi√©n copiar a la ra√≠z (para compatibilidad)
            destino_raiz = f"{dist_final}/BaseDatos.json"
            
            try:
                # Crear carpeta _internal/BaseDatos
                os.makedirs(os.path.dirname(destino_internal), exist_ok=True)
                shutil.copy2(backup_path, destino_internal)
                print(f"‚úÖ BaseDatos.json ‚Üí _internal/BaseDatos/")
                
                # Tambi√©n copiar a ra√≠z
                shutil.copy2(backup_path, destino_raiz)
                print(f"‚úÖ BaseDatos.json ‚Üí ra√≠z del ejecutable")
                
                os.remove(backup_path)
                break
            except Exception as e:
                print(f"‚ö†Ô∏è Error restaurando BaseDatos.json: {e}")
    
    # 6. ELIMINAR ARCHIVOS NO DESEADOS (por si acaso)
    limpiar_archivos_no_deseados()
    
    return True

def verificar_estructura_final_simplificada():
    """Verifica la estructura final SIMPLIFICADA"""
    print("\nüîç Verificando estructura final SIMPLIFICADA...")
    
    dist_final = "dist/generador_actas"
    
    # Verificar ejecutables
    ejecutables = [
        ("generador_actas.exe", "üöÄ PRINCIPAL (sin consola)"),
        ("generador_actas_console.exe", "üñ•Ô∏è CON CONSOLA")
    ]
    
    for ejecutable, descripcion in ejecutables:
        exe_path = f"{dist_final}/{ejecutable}"
        if os.path.exists(exe_path):
            size_mb = os.path.getsize(exe_path) / (1024 * 1024)
            print(f"‚úÖ {ejecutable} ({size_mb:.1f} MB) - {descripcion}")
        else:
            print(f"‚ùå {ejecutable} - NO ENCONTRADO")
            return False
    
    # Verificar _internal
    internal_path = f"{dist_final}/_internal"
    if os.path.exists(internal_path):
        archivos_internal = os.listdir(internal_path)
        print(f"‚úÖ _internal/ ({len(archivos_internal)} elementos)")
        
        # Verificar BaseDatos dentro de _internal
        basedatos_path = f"{internal_path}/BaseDatos"
        if os.path.exists(basedatos_path):
            basedatos_archivos = os.listdir(basedatos_path)
            json_files = [f for f in basedatos_archivos if f.endswith('.json')]
            print(f"‚úÖ _internal/BaseDatos/ ({len(json_files)} archivos JSON)")
            
            # Mostrar archivos JSON
            for json_file in json_files[:3]:  # M√°ximo 3
                print(f"     üìÑ {json_file}")
            if len(json_files) > 3:
                print(f"     ... y {len(json_files)-3} archivos m√°s")
        else:
            print("‚ùå _internal/BaseDatos/ - NO ENCONTRADO")
    else:
        print("‚ùå _internal/ - NO ENCONTRADO")
        return False
    
    # Verificar obras (opcional pero recomendado)
    obras_path = f"{dist_final}/obras"
    if os.path.exists(obras_path):
        obras_archivos = os.listdir(obras_path)
        print(f"‚úÖ obras/ ({len(obras_archivos)} elementos) üõ°Ô∏è PRESERVADO")
    else:
        print("‚ö†Ô∏è obras/ - No encontrado (puede ser normal)")
    
    # Calcular tama√±o total
    try:
        tamano_total = 0
        archivo_count = 0
        for root, dirs, files in os.walk(dist_final):
            for file in files:
                filepath = os.path.join(root, file)
                if os.path.exists(filepath):
                    tamano_total += os.path.getsize(filepath)
                    archivo_count += 1
        
        tamano_mb = tamano_total / (1024 * 1024)
        print(f"\nüìä Estad√≠sticas:")
        print(f"   üì¶ Tama√±o total: {tamano_mb:.1f} MB")
        print(f"   üìÑ Archivos totales: {archivo_count}")
    except Exception as e:
        print(f"‚ö†Ô∏è Error calculando estad√≠sticas: {e}")
    
    # Verificar que NO existen archivos no deseados
    print(f"\nüóëÔ∏è Verificando que archivos no deseados fueron eliminados:")
    archivos_no_deseados = [
        "ejecutar.bat", "README.txt", "historial_documentos.json", 
        "generador_actas.exe.old"
    ]
    
    carpetas_no_deseadas = ["obras_backup_compilacion", "reportes"]
    
    todos_limpio = True
    for archivo in archivos_no_deseados:
        archivo_path = f"{dist_final}/{archivo}"
        if os.path.exists(archivo_path):
            print(f"‚ö†Ô∏è {archivo} - A√öN EXISTE (se eliminar√°)")
            try:
                os.remove(archivo_path)
                print(f"‚úÖ {archivo} - ELIMINADO")
            except:
                todos_limpio = False
        else:
            print(f"‚úÖ {archivo} - No existe (correcto)")
    
    for carpeta in carpetas_no_deseadas:
        carpeta_path = f"{dist_final}/{carpeta}"
        if os.path.exists(carpeta_path):
            print(f"‚ö†Ô∏è {carpeta}/ - A√öN EXISTE (se eliminar√°)")
            try:
                shutil.rmtree(carpeta_path)
                print(f"‚úÖ {carpeta}/ - ELIMINADO")
            except:
                todos_limpio = False
        else:
            print(f"‚úÖ {carpeta}/ - No existe (correcto)")
    
    if todos_limpio:
        print("‚úÖ Estructura limpia correctamente")
    
    return True

def limpiar_temporales():
    """Limpia archivos temporales de compilaci√≥n"""
    print("\nüßπ Limpiando archivos temporales...")
    
    archivos_temporales = [
        "dist_temp", 
        "build",
        "__pycache__",
        "generador_actas.spec",        # Eliminar spec files para forzar regeneraci√≥n limpia
        "generador_actas_console.spec",
        "validar_entorno.py"           # Eliminar si existe
    ]
    
    for archivo in archivos_temporales:
        if os.path.exists(archivo):
            try:
                if os.path.isdir(archivo):
                    shutil.rmtree(archivo)
                    print(f"‚úÖ {archivo}/ eliminado")
                else:
                    os.remove(archivo)
                    print(f"‚úÖ {archivo} eliminado")
            except Exception as e:
                print(f"‚ö†Ô∏è Error eliminando {archivo}: {e}")

def main():
    """Funci√≥n principal de compilaci√≥n SIMPLIFICADA"""
    print("=" * 70)
    print("   COMPILADOR GENERADOR ACTAS ADIF - v5.0 (SIMPLIFICADO)")
    print("=" * 70)
    
    # PASO 0: Preservar archivos cr√≠ticos
    backups = preservar_archivos_criticos()
    
    # Detectar entorno virtual
    python_exe = activar_entorno_virtual()
    
    # Verificar dependencias
    if not verificar_dependencias(python_exe):
        print("\n‚ùå FALTAN DEPENDENCIAS")
        return False
    
    # Verificar archivos necesarios
    if not verificar_archivos_necesarios():
        print("\n‚ùå FALTAN ARCHIVOS NECESARIOS")
        return False
    
    # Verificar PyInstaller
    try:
        subprocess.run([python_exe, "-c", "import PyInstaller"], check=True, capture_output=True)
        print("‚úÖ PyInstaller disponible")
    except subprocess.CalledProcessError:
        print("üì¶ Instalando PyInstaller...")
        subprocess.run([python_exe, "-m", "pip", "install", "pyinstaller"])
    
    # Limpiar compilaciones anteriores
    limpiar_temporales()
    
    # PASO 1: Compilar AMBOS ejecutables
    if not compilar_aplicacion_doble(python_exe):
        print("‚ùå Error en compilaci√≥n")
        return False
    
    # PASO 2: Crear estructura simplificada
    if not crear_estructura_simplificada(backups):
        print("‚ùå Error creando estructura simplificada")
        return False
    
    # PASO 3: Verificar resultado final
    if not verificar_estructura_final_simplificada():
        print("‚ùå Error en verificaci√≥n final")
        return False
    
    # PASO 4: Limpiar temporales
    limpiar_temporales()
    
    # √âXITO
    print("\n" + "=" * 70)
    print("üéâ ¬°COMPILACI√ìN EXITOSA - ESTRUCTURA SIMPLIFICADA!")
    print("=" * 70)
    
    print("\nüìÅ ESTRUCTURA FINAL:")
    print("dist/generador_actas/")
    print("‚îú‚îÄ‚îÄ generador_actas.exe         (üöÄ EJECUTABLE PRINCIPAL - SIN consola)")
    print("‚îú‚îÄ‚îÄ generador_actas_console.exe (üñ•Ô∏è EJECUTABLE CON consola)")
    print("‚îú‚îÄ‚îÄ _internal/                  (üì¶ Archivos internos)")
    print("‚îÇ   ‚îú‚îÄ‚îÄ BaseDatos/              (üóÑÔ∏è Base de datos DENTRO de _internal)")
    print("‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ BaseDatos.json")
    print("‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ backups autom√°ticos")
    print("‚îÇ   ‚îú‚îÄ‚îÄ plantillas/             (üìÑ Archivos .docx)")
    print("‚îÇ   ‚îú‚îÄ‚îÄ otros/                  (üé® UI y recursos)")
    print("‚îÇ   ‚îî‚îÄ‚îÄ [librer√≠as PyInstaller]")
    print("‚îî‚îÄ‚îÄ obras/                      (üõ°Ô∏è CARPETA PRESERVADA)")
    
    print(f"\nüöÄ PARA EJECUTAR:")
    print("- MODO NORMAL: generador_actas.exe")
    print("- MODO DEBUG:  generador_actas_console.exe")
    
    print(f"\n‚úÖ ARCHIVOS ELIMINADOS:")
    print("- ejecutar.bat")
    print("- README.txt") 
    print("- historial_documentos.json")
    print("- generador_actas.exe.old")
    print("- obras_backup_compilacion/")
    print("- reportes/")
    
    return True

if __name__ == "__main__":
    print("üöÄ Generador de Actas ADIF - Compilador v5.0 (SIMPLIFICADO)")
    print("üì¶ Estructura: Solo ejecutables + _internal + obras")
    print("üõ°Ô∏è Preserva: BaseDatos y obras")
    print("üóëÔ∏è Elimina: ejecutar.bat, README.txt, historial, reportes, backups")
    
    # Permitir compilaci√≥n sin entorno virtual
    print("\nüîç Iniciando compilaci√≥n...")
    print("üí° Modo: Estructura simplificada con doble ejecutable")
    
    try:
        success = main()
    except KeyboardInterrupt:
        print("\n\n‚èπÔ∏è Compilaci√≥n interrumpida por el usuario")
        success = False
    except Exception as e:
        print(f"\n\nüí• Error inesperado durante la compilaci√≥n: {e}")
        import traceback
        traceback.print_exc()
        success = False
    
    print(f"\n{'='*70}")
    if success:
        print("üéä ¬°COMPILACI√ìN COMPLETADA - ESTRUCTURA SIMPLIFICADA!")
        print("üìÅ Ubicaci√≥n: dist/generador_actas/")
        
        print("\nüìã ESTRUCTURA FINAL GENERADA:")
        print("üöÄ generador_actas.exe         (ejecutable principal - SIN consola)")
        print("üñ•Ô∏è generador_actas_console.exe (ejecutable con consola - DEBUG)")
        print("üì¶ _internal/                  (archivos internos del programa)")
        print("üóÑÔ∏è _internal/BaseDatos/        (base de datos MOVIDA aqu√≠)")
        print("üõ°Ô∏è obras/                     (carpeta de proyectos PRESERVADA)")
        
        print("\nüóëÔ∏è ARCHIVOS/CARPETAS ELIMINADOS:")
        print("‚ùå ejecutar.bat")
        print("‚ùå README.txt")
        print("‚ùå historial_documentos.json")
        print("‚ùå generador_actas.exe.old")
        print("‚ùå obras_backup_compilacion/")
        print("‚ùå reportes/")
        
        print("\nüéØ INSTRUCCIONES DE USO:")
        print("1. Ve a: dist/generador_actas/")
        print("2. Ejecuta: generador_actas.exe (modo normal)")
        print("3. O ejecuta: generador_actas_console.exe (si necesitas debug)")
        
        print("\nüí° NOTAS IMPORTANTES:")
        print("‚Ä¢ BaseDatos ahora est√° en: _internal/BaseDatos/")
        print("‚Ä¢ Carpeta obras se mantiene en la ra√≠z")
        print("‚Ä¢ Archivos innecesarios han sido eliminados")
        print("‚Ä¢ Dos ejecutables disponibles: normal y con consola")
        
    else:
        print("üí• ERROR EN COMPILACI√ìN")
        print("üîç Revisa los mensajes de error anteriores")
        print("üí° Sugerencias:")
        print("   - Verifica que tienes todas las dependencias")
        print("   - Comprueba que main_py.py existe")
        print("   - Aseg√∫rate de tener permisos de escritura")
    
    print(f"\n{'='*70}")
    input("‚è∏Ô∏è Presiona Enter para salir...")
    sys.exit(0 if success else 1)